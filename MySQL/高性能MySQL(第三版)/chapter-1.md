## 1.2并发控制



### 1.2.1 读写锁

- 共享锁（读锁），读锁是共享的，互相不阻塞，多个客户在同一时刻可以同时读取同一资源，互不干扰
- 排他锁（写锁），写锁是排他的，一个写锁会阻塞其他的写锁和读锁。



### 1.2.2 锁粒度



- 锁策略。加锁需要耗费资源，太过细致的锁会增加锁管理的时间和性能，所以需要在锁的开销和数据的安全性之间寻找平衡
- 表锁（table lock），最基本的锁策略，也是开销最小的策略，写锁比读锁有更高的优先级
- 行级锁（row lock) ，行级锁可以最大程度地支持并发处理，同时也会带来最大的所开销，InnoDB和XtraDBz和其他一些引擎进行了实现，而行级锁只在存储引擎层进行了实现，服务层没有实现。

## 1.3事务

 	概括来说，失误就是一组原子性的SQL查询，其他概念大致和sql server一致

​	事务的ACID概念：原子性(atomicity)、一致性(consistency)、隔离性(isolation)和持久性(durability)，ACID的实现会增加系统额外的花销。

- 原子性(atomicity),一个事务必须被视为一个不可分割的最小工作单元,整个事务中的所有操作要么全部提交成功,要么全部失败回滚,对于一个事务来说,不可能只执行其中的一部分,操作,这就是事务的原子性。

- 一致性(consistency),数据库总是从一个一致性的状态转换到另外一个一致性的状态,如果事务执行过程中系统崩溃，系统最终不会出现数据异常，因为事务最终没有提交,所以事务中所做的修改也不会保存到数据库中。

- 隔离性(isolation) ，通常来说,一个事务所做的修改在最终提交以前、对其他事务是不可见的。

- 持久性durability)，一旦事务提交,则其所做的修改就会永久保存到数据库中,此时即使系统崩溃,修改的数据也不会丢失,持久性是个有点模糊的概念,因为实际上持久性也分很多不同的级别,有些持久性策略能够提供非常强的安全保障,而有些则未必,而不可能有能做到100%的持久性保证的策路(如果数据库本身就能做到真正的持久,那么备份又怎么能增加持久性呢? )

  ### 1.3.1 隔离级别

  READ UNCOMMITTED、READ COMMITTED、REPEATED READ、SERIALIZABLE

  

  ### 1.3.2 死锁

  死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。

  

  为了解决死锁，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，比如InnoDB存储引擎，越能检测到死锁的循环以来，并立即返回一个错误。InnoDB目前处理死锁的方法是，讲持有最少行级排他锁的事务进行回滚。

  

  死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁。

  

  ### 1.3.3 事务日志

  事务日志可以帮助提高事务的效率。使用事务日志,存储引肇在修改表的数据时只需要修改其内存拷贝,再把该修改行为记录到持久在硬盘上的事务日志中,而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式,因此写日志的操作是磁盘上一小块区域内的顺序1/0,而不像随机1/0需要在磁盘的多个地方移动磁头,所以采用事务日志的方式相对来说要快得多。事务日志持久以后,内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的,我们通常称之为预写式日志(Write-Ahead Logging),修改数据需要写两次磁盘。

  如果数据的修改已经记录到事务日志并持久化,但数据本身还没有写回磁盘,此时系统崩溃,存储引擎在重启时能够自动恢复这部分修改的数据。具体的恢复方式则视存储引擎而定.

  

  ### 1.3.4 MySQL中的事务

  MySQL提供了两种事务型的存储引擎：InnoDB和NDB Cluster。

  **自动提交（AUTOCOMMIT)**

  MySQL默认采用自动提交模式，如果不是显示地开始一个事务，则每个查询都被当做一个事务执行操作。

  **在事务中混合使用存储引擎**

  统一事务中使用多种存储引擎是不可靠的。如果在十五中混合使用了事务型和非事务型的表，正常提交没问题，但是当需要回滚的时候，非事务型的表上的变更就无法撤销，导致数据库处于不一致的状态。

  **隐式和显式锁定**

  InnoDB采用的是两阶段锁定协议。隐式锁定是指在事务执行过程中，随时都可以执行锁定，锁只有在执行`COMMITH`或者`ROLLBACK`的时候才会释放，并且所有的锁都是在同一时刻被释放。

  显示锁定是指，在服务层通过`LOCK TABLES`和`UNLOCK TABLES`语句来实现表锁定。

  

  <u>书中建议：除了事务中禁用了AUTOCOMMIT，可以使用LOCK TABLES之外，其他任何时候都不要显示地执行LOCK  TABLES，不管使用的是什么存储引擎</u>

  ## 1.4多版本并发控制


  MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑,它们一般都同时实现了多版本并发控制(MVCC),不仅是MySQL,包括Oracle、PostgreSQL等其他数据库系统也都实现了MVCC,但各自的实现机制不尽相同,因为MVCC没有一个统一的实现标准。

  可以认为MVCC是行级锁的一个变种,但是它在很多情况下避免了加锁操作,因此开销更低。虽然实现机制有所不同,但大都实现了非阻塞的读操作,写操作也只锁定必要的行。

  MVCC的实现,是通过保存数据在某个时间点的快照来实现的。也就是说,不管需要执,行多长时间,每个事务看到的数据都是一致的。根据事务开始的时间不同,每个事务对,同一张表,同一时刻看到的数据可能是不一样的。

  ## 1.5 MySQL的存储引擎

  详细介绍看书中详细说明，重点是InnoDB存储引擎。

  










